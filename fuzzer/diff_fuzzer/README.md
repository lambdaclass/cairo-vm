# Random hint fuzzer

This fuzzer takes a list of pre-selected hints and runs a generated basic program with randomized inputs that uses a random hint from the list.

## To run the fuzzer 

Use the commands:
 - `make fuzzer-deps` to ensure that you have the atheris module and created a python module from `fuzzer/src/py_export.rs` using maturin.
 - `make fuzzer-run-hint-diff` to run the fuzzer.

## The fuzzer
The fuzzer is located in the ***random_hint_fuzzer.py*** file inside the diff_fuzzer folder.

### How does it work?

1. Hints are loaded by `load_hints()` from `fuzzer/diff_fuzzer/hint_reader.py`, which extracts hint code snippets from `vm/src/hint_processor/builtin_hint_processor/hint_code.rs` using a regex and filters to hints that contain right-shift operations or `SECP_P`. A random hint is then selected via Atheris’ fuzzed data provider with `fdp.PickValueInList(LOADED_HINTS)`.
2. A basic program using the selected hint is generated by `generate_cairo_hint_program`, which returns Cairo code with a `REPLACEABLE_TOKEN` placeholder wherever a randomized value should be injected.
3. All `REPLACEABLE_TOKEN` occurrences are replaced with random values using `generate_limb`. The probabilities are: 70% for a value in the interval ***[PRIME >> 1, PRIME]***, 15% for ***[0, 10]***, and 15% for ***[1, PRIME]***, where `PRIME = 2**251 + 17 * 2**192 + 1`.
4. The program is compiled in-memory with `starkware.cairo.lang.compiler.cairo_compile.compile_cairo(...)`; no `.cairo` or `.json` file is written during normal operation.
5. The compiled program is executed by both the Python VM (`CairoRunner` with `LAYOUTS["plain"]`) and the Rust VM (`cairo_vm_rs.cairo_run_dump_mem`).
6. If both implementations succeed, `check_mem` compares their relocated memories. If exactly one side errors, an assertion is triggered. For debugging, on failures the fuzzer writes a reproducible `.cairo` input to a file named like `failed_input_<hex>.cairo`.

## The program generator 

The program generator is located in the ***cairo_program_gen.py*** file inside the diff_fuzzer folder.

### How does it work?

1. Grab a hint given by the fuzzer.
2. Look for all the `ids.(...)` expressions, make sure to keep track of any ***"="*** to the left or right. Also check for cairo constants
3. Reduce the `ids.(...)` expressions so that all the variables are grouped with their fields.
4. After looking at the `ids.(...)`, import `EcPoint`, `BigInt3` or any cairo constants needed for the hint to run.
5. Create dictionaries and classify the variables from step 3
        - declare_in_main: if ***"="*** was to the ***right***
        - declare_in_hint_fn: if ***"="*** was to the ***left***
6. Create `main` using `declare_in_main` variables and pass them as arguments to `hint_func`
        
    ```
    func main() {
                let a = MyStruct(field=1, field=2);
                hint_func(a);
                return();
              }
    ```

7. Create `hint_func` with variables from `declare_in_hint_fn` as locals. The function signature includes the inputs from `declare_in_main` and returns all variables from `declare_in_main ∪ declare_in_hint_fn` (as a tuple when there is more than one).
     ```
    hint_func(a: MyStruct) -> (MyStruct) {
            alloc_locals;
            local b: MyStruct;
            %{
              ...
            %}
            return(b);
          }
    ```
    
8. Import any required Cairo constants (e.g., `ADDR_BOUND`) and return the entire generated program
